/***************************************************************** 
 *
 * LUP分解
 *
 *
 *                           Created  by Mamoru Ota (2018/03/09)
 * 
 *****************************************************************/

#include"common.h"

INT  T__MATRIX_LUP_DECOMPOSITION(TYPE A[],//(out,in) [n * n] : 入力正方行列, LU分解結果が格納される
                                 INT  P[],//(out,in) [n]     : 置換配列
                                 INT  n){ //(in)             : 行列の次元数
  INT  i,j,k;
  INT  buf,l;
  REAL max,val;
  TYPE tmp;
  
  // ****************************************************************
  // 引数チェック
  // ****************************************************************
  if((A == NULL) || (P == NULL) || (n < 1)){
    ERROR__SHOW("#1");
    return -1;
  }
  // ****************************************************************
  // 置換配列(i -> P[i])の初期化
  // ****************************************************************
  for(i = 0;i < n;i++){
    P[i] = i;
  }
  // ****************************************************************
  // LU分解
  // ****************************************************************
  for(k = 0;k < n - 1;k++){
    // **************************************************************
    // Pivot選択
    // **************************************************************
    max = T__ABS(A[k * n + k]);
    l   = k;
    for(i = k + 1;i < n;i++){
      val = T__ABS(A[i * n + k]);
      if(REAL__GT(val,max)){
	 max = val;
	 l   = i;
      }
    }
    // **************************************************************
    // 行の交換
    // **************************************************************
    if(k != l){
      buf  = P[k];
      P[k] = P[l];
      P[l] = buf;
      for(j = 0;j < n;j++){
	tmp          = A[k * n + j];
	A[k * n + j] = A[l * n + j];
	A[l * n + j] = tmp;
      }
    }
    // **************************************************************
    // 行列の更新
    // **************************************************************
    for(i = k + 1;i < n;i++){
      tmp = A[k * n + k];
      if(T__EQ(tmp,T__ZERO())){
        ERROR__SHOW("#2");
	return -1;
      }
      tmp          = T__DIV(A[i * n + k],tmp);      
      A[i * n + k] = tmp;
      for(j = k + 1;j < n;j++){
	A[i * n + j] = T__FMA(T__NEGATIVE(tmp),A[k * n + j],A[i * n + j]);
      }
    }
  }
  return 0;
}
