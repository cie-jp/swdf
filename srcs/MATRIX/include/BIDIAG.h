/***************************************************************** 
 *
 * 2重対角化
 *
 *
 *                           Created  by Mamoru Ota (2018/03/09)
 * 
 *****************************************************************/

#include"common.h"

// *******************************************************************
// row行col列の実・複素行列AをHouseholder変換により
// 実2重対角行列
//            | b0[0]  b1[0]     0      0  ...         0          0  |
//            |    0   b0[1]  b1[1]     0  ...         .          .  |
//            |    0      0   b0[2]  b1[2] ...         .          .  |
// B        = |    0      0      0   b0[3] ...         .          .  |
//            |    .      .      .      .              0          0  |
//            |    0      0      0      0       b1[n - 3]         0  |
//            |    0      0      0      0  ...  b0[n - 2]  b1[n - 2] | 
//            |    0      0      0      0  ...         0   b0[n - 1] |
// に変換する.
// 入力行列であるAは, 変換行列の情報を表すように関数により変更され,
// 以下のように(u,v)の情報が格納される. 
//
//            |                 0  |
//            |                 .  |
//            |                 0  |
//            | A[     k  * n + k] |
// u[k]     = | A[     3  * n + k] |
//            |           .        |
//            | A[(n - 3) * n + k] |
//            | A[(n - 2) * n + k] |
//            | A[(n - 1) * n + k] |
//
//            |                 0  |
//            |                 .  |
//            |                 0  |
//            |                 0  |
// v[k]     = | A[k * n + (k + 1)] |
//            |                 .  |
//            | A[k * n + (n - 3)] |
//            | A[k * n + (n - 2)] |
//            | A[k * n + (n - 1)] |
// 
// Pu[k] = (I - (1 + wu[k]) * u[k] * u[k]^{dag})
// Pv[k] = (I - (1 + wv[k]) * v[k] * v[k]^{dag})
// として,
// B = Pu[dim - 1]Pu[dim - 2]...Pu[1]Pu[0]APv[0]Pv[1]...Pv[dim - 1]
// となっている. 
// *******************************************************************

void T__MATRIX_BIDIAG(REAL b0[],//(out) [dim]     2重対角行列の  対角成分 (dim = min(row,col))
                      REAL b1[],//(out) [dim - 1] 2重対角行列の非対角成分
                      TYPE wu[],//(out) [row]
                      TYPE wv[],//(out) [col]
                      TYPE A [],//(io)  [row * col]
                      INT  row, //(in)
                      INT  col){//(in)
  void *mem;
  TYPE *u;//[row]
  TYPE *v;//[col]
  TYPE  y0;
  REAL  len;
  TYPE  tmp;
  int   i,j,c;

  // ******************************************************************
  //  1. 作業変数のメモリ確保
  // ******************************************************************
  if((mem = malloc(sizeof(TYPE) * row
                 + sizeof(TYPE) * col)) == NULL){
    ERROR__SHOW("#1");
    exit(EXIT_FAILURE);    
  }

  // ******************************************************************
  //  2. メモリ割り当て
  // ******************************************************************
  u = (TYPE*)mem;  
  v = (TYPE*)&u[row];

  for(c = 0;c < col;c++){
    // ****************************************************************
    // 対象となる列ベクトルuの取得
    // ****************************************************************
    for(i = c;i < row;i++){
      u[i] = A[i * col + c];
    }
    // ****************************************************************
    // ノルムの計算
    // ****************************************************************
    len = REAL__ZERO();
    for(i = c;i < row;i++){
      len = REAL__ADD(len,T__NORM(u[i]));
    }
    if(REAL__NEQ(len,REAL__ZERO())){
      len = REAL__SQRT(len);
      if(REAL__GE(T__REAL(u[c]),REAL__ZERO())){
        y0 = T__NEGATIVE(T__MAKE(len));
      }else{
        y0 = T__POSITIVE(T__MAKE(len));
      }
      wu[c] = T__DIV(T__CONJ(T__SUB(y0,u[c])),T__SUB(y0,u[c]));
      tmp   = T__MAKE(REAL__SQRT(REAL__DIV(REAL__ONE(),REAL__MUL(REAL__TWO(),T__REAL(T__MUL(T__CONJ(y0),T__SUB(y0,u[c])))))));
      b0[c] = T__REAL(y0);
      u [c] = T__SUB(u[c],y0);
      // ****************************************************************
      // 規格化処理
      // ****************************************************************
      for(i = c;i < row;i++){
        u[i] = T__MUL(u[i],tmp);
      }
      // ****************************************************************
      // v = A'uの計算
      // ****************************************************************
      for(j = c + 1;j < col;j++){
        tmp = T__ZERO();
        for(i = c;i < row;i++){
          tmp = T__FMA(T__CONJ(A[i * col + j]),u[i],tmp);
        }
        v[j] = tmp;
      }
      // ****************************************************************
      // A = A - (1 + w)uv'
      // ****************************************************************
      for(i = c;i < row;i++){
        for(j = c + 1;j < col;j++){
          A[i * col + j] = T__FMA(T__MUL(T__NEGATIVE(T__ADD(T__ONE(),wu[c])),u[i]),T__CONJ(v[j]),A[i * col + j]);
        }
      }
      // ****************************************************************
      // uの代入
      // ****************************************************************
      for(i = c;i < row;i++){
        A[i * col + c] = u[i];
      }
    }
    if((c + 1) >= col){
      break;
    }

    // ****************************************************************
    // 対象となる行ベクトルvの取得
    // ****************************************************************
    for(j = c + 1;j < col;j++){
      v[j] = T__CONJ(A[c * col + j]);
    }
    // ****************************************************************
    // ノルムの計算
    // ****************************************************************
    len = 0.0;
    for(j = c + 1;j < col;j++){
      len = REAL__ADD(len,T__NORM(v[j]));
    }
    if(REAL__EQ(len,REAL__ZERO())){
      b1[c] = T__ZERO();
    }else{
      len = REAL__SQRT(len);
      if(REAL__GE(T__REAL(v[c + 1]),REAL__ZERO())){
        y0 = T__NEGATIVE(T__MAKE(len));
      }else{
        y0 = T__POSITIVE(T__MAKE(len));
      }
      wv[c]    = T__CONJ(T__DIV(T__CONJ(T__SUB(y0,v[c + 1])),T__SUB(y0,v[c + 1])));
      tmp      = T__MAKE(REAL__SQRT(REAL__DIV(REAL__ONE(),REAL__MUL(REAL__TWO(),T__REAL(T__MUL(T__CONJ(y0),T__SUB(y0,v[c + 1])))))));
      b1[c]    = T__REAL(y0);
      v[c + 1] = T__SUB(v[c + 1],y0);
      // ****************************************************************
      // 規格化処理
      // ****************************************************************
      for(j = c + 1;j < col;j++){
        v[j] = T__MUL(v[j],tmp);
      }
      // ****************************************************************
      // u = Avの計算
      // ****************************************************************
      for(i = c + 1;i < row;i++){
        tmp = T__ZERO();
        for(j = c + 1;j < col;j++){
          tmp = T__FMA(A[i * col + j],v[j],tmp);
        }
        u[i] = tmp;
      }
      // ****************************************************************
      //A = A - (1 + w)uv'
      // ****************************************************************
      for(i = c + 1;i < row;i++){
        for(j = c + 1;j < col;j++){
          A[i * col + j] = T__FMA(T__MUL(T__NEGATIVE(T__ADD(T__ONE(),wv[c])),u[i]),T__CONJ(v[j]),A[i * col + j]);
        }
      }
      // ****************************************************************
      // vの代入
      // ****************************************************************
      for(j = c + 1;j < col;j++){
        A[c * col + j] = T__CONJ(v[j]);
      }
    }
  }

  // ******************************************************************
  // 13. 作業変数のメモリ解放
  // ******************************************************************
  free(mem);  
}
