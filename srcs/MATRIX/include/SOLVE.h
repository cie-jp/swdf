/***************************************************************** 
 *
 * 連立方程式の解
 *
 *
 *                           Created  by Mamoru Ota (2018/03/09)
 * 
 *****************************************************************/

#include"common.h"

INT  T__MATRIX_SOLVE(TYPE x[],//(out) [n]
                     TYPE A[],//(in)  [n * n]
                     TYPE b[],//(in)  [n]
                     INT  n){ //(in)
  INT   i,j,c;
  INT  *P; //[n]
  TYPE *y; //[n]
  TYPE *LU;//[n * n]
  TYPE  tmp;

  // ****************************************************************
  // 引数チェック
  // ****************************************************************
  if((x == NULL) || (A == NULL) || (b == NULL) || (n < 1)){
    ERROR__SHOW("#1");
    return -1;
  }
  // ****************************************************************
  // メモリの確保と初期化
  // ****************************************************************
  c = sizeof(INT) * n + sizeof(TYPE) * (n + n * n);
  if((P = (INT*)malloc(c)) == NULL){
    ERROR__SHOW("#2");
    return -1;
  }
  y  = (TYPE*)(P + n);
  LU = y + n;
  memcpy(LU,A,n * n * sizeof(TYPE));
  // ****************************************************************
  // LUP分解
  // ****************************************************************
  if(T__MATRIX_LUP_DECOMPOSITION(LU,P,n) == -1){
    free(P);
    return -1;
  }
  // ****************************************************************
  // 前進代入(Ly = b)
  // ****************************************************************
  y[0] = b[P[0]];
  for(j = 1;j < n;j++){
    tmp = b[P[j]];
    for(i = 0;i < j;i++){
      tmp = T__FMA(T__NEGATIVE(LU[j * n + i]),y[i],tmp);
    }
    y[j] = tmp;
  }
  // ****************************************************************
  // 後退代入(Ux = y)
  // ****************************************************************
  for(j = n - 1;j >= 0;j--){
    tmp = y[j];
    for(i = j + 1;i < n;i++){
      tmp = T__FMA(T__NEGATIVE(LU[j * n + i]),x[i],tmp);
    }
    x[j] = tmp;
    tmp  = LU[j * n + j];
    if(T__EQ(tmp,T__ZERO())){
      ERROR__SHOW("#3");
      return -1;
    }
    x[j] = T__DIV(x[j],tmp);
  }
  // ****************************************************************
  // メモリの解放
  // ****************************************************************
  free(P);
  return 0;
}
