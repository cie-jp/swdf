/***************************************************************** 
 *
 * QR分解
 *
 *
 *                           Created  by Mamoru Ota (2018/06/09)
 * 
 *****************************************************************/

#include"common.h"

// *******************************************************************
// row行col列の実・複素行列AをHouseholder変換によりQR分解する. 
// 実2重対角行列
//            | b0[0]  b1[0]     0      0  ...         0          0  |
//            |    0   b0[1]  b1[1]     0  ...         .          .  |
//            |    0      0   b0[2]  b1[2] ...         .          .  |
// B        = |    0      0      0   b0[3] ...         .          .  |
//            |    .      .      .      .              0          0  |
//            |    0      0      0      0       b1[n - 3]         0  |
//            |    0      0      0      0  ...  b0[n - 2]  b1[n - 2] | 
//            |    0      0      0      0  ...         0   b0[n - 1] |
// に変換する. ただし, row >= colである場合にのみ適用できる. 
// 入力行列であるAは, 変換行列の情報を表すように関数により変更され,
// 以下のように(u,v)の情報が格納される. 
//
//            |                   0  |
//            |                   .  |
//            |                   0  |
//            | A[     k  * col + k] |
// u[k]     = | A[     3  * col + k] | (row次元)
//            |                   .  |
//            | A[(n - 3) * col + k] |
//            | A[(n - 2) * col + k] |
//            | A[(n - 1) * col + k] |
//
//            |                   0  |
//            |                   .  |
//            |                   0  |
//            |                   0  |
// v[k]     = | A[k * col + (k + 1)] | (col次元)
//            |                   .  |
//            | A[k * col + (n - 3)] |
//            | A[k * col + (n - 2)] |
//            | A[k * col + (n - 1)] |
// 
// Pu[k] = (I - (1 + wu[k]) * u[k] * u[k]^{dag})
// Pv[k] = (I - (1 + wv[k]) * v[k] * v[k]^{dag})
// として,
// B = Pu[row - 1]Pu[row - 2]...Pu[1]Pu[0]APv[0]Pv[1]...Pv[col - 2]
// となっている. 
// *******************************************************************

void T__MATRIX_QR(REAL b0[],//(out) [min(row,col)]
                  TYPE wu[],//(out) [min(row,col)]
                  TYPE A [],//(io)  [row * col]
                  INT  row,
                  INT  col){
  INT   dim = (row < col) ? row : col;
  void *mem;
  TYPE *u;//[row]
  TYPE *v;//[col]
  TYPE  y0;
  REAL  len;
  TYPE  tmp;
  INT   i,j,c;

  // ******************************************************************
  //  1. 作業変数のメモリ確保
  // ******************************************************************
  if((mem = malloc(sizeof(TYPE) * row
                 + sizeof(TYPE) * col)) == NULL){
    ERROR__SHOW("#1");
    exit(EXIT_FAILURE);    
  }

  // ******************************************************************
  //  2. メモリ割り当て
  // ******************************************************************
  u = (TYPE*)mem;
  v = (TYPE*)&u[row];

  for(c = 0;c < dim;c++){
    // ****************************************************************
    // 対象となる列ベクトルuの取得
    // ****************************************************************
    for(i = c;i < row;i++){
      u[i] = A[i * col + c];
    }
    // ****************************************************************
    // ノルムの計算
    // ****************************************************************
    len = REAL__ZERO();
    for(i = c;i < row;i++){
      len = REAL__ADD(len,T__NORM(u[i]));
    }
    if(REAL__NEQ(len,REAL__ZERO())){
      len = REAL__SQRT(len);
      if(REAL__GE(T__REAL(u[c]),REAL__ZERO())){
        y0 = T__NEGATIVE(T__MAKE(len));
      }else{
        y0 = T__POSITIVE(T__MAKE(len));
      }
      wu[c] = T__DIV(T__CONJ(T__SUB(y0,u[c])),T__SUB(y0,u[c]));
      tmp   = T__MAKE(REAL__SQRT(REAL__DIV(REAL__ONE(),REAL__MUL(REAL__TWO(),T__REAL(T__MUL(T__CONJ(y0),T__SUB(y0,u[c])))))));
      b0[c] = T__REAL(y0);
      u [c] = T__SUB(u[c],y0);
      // ****************************************************************
      // 規格化処理
      // ****************************************************************
      for(i = c;i < row;i++){
        u[i] = T__MUL(u[i],tmp);
      }
      // ****************************************************************
      // v = A'uの計算
      // ****************************************************************
      for(j = c + 1;j < col;j++){
        tmp = T__ZERO();
        for(i = c;i < row;i++){
          tmp = T__FMA(T__CONJ(A[i * col + j]),u[i],tmp);
        }
        v[j] = tmp;
      }
      // ****************************************************************
      // A = A - (1 + w)uv'
      // ****************************************************************
      for(i = c;i < row;i++){
        for(j = c + 1;j < col;j++){
          A[i * col + j] = T__FMA(T__MUL(T__NEGATIVE(T__ADD(T__ONE(),wu[c])),u[i]),T__CONJ(v[j]),A[i * col + j]);
        }
      }
      // ****************************************************************
      // uの代入
      // ****************************************************************
      for(i = c;i < row;i++){
        A[i * col + c] = u[i];
      }
    }
  }

  // ******************************************************************
  // 3. 作業変数のメモリ解放
  // ******************************************************************
  free(mem);
}
