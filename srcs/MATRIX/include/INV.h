/***************************************************************** 
 *
 * 逆行列
 *
 *
 *                           Created  by Mamoru Ota (2018/03/09)
 * 
 *****************************************************************/

#include"common.h"

INT  T__MATRIX_INV(TYPE A[],//(out,in) [n * n]
                   INT  n){ //(in)
  // 関数ポインタ
  INT   i,j,k,c;
  INT  *P;     //[n]
  TYPE *LU_inv;//[n * n]
  TYPE  tmp,dj;
  
  // ****************************************************************
  // 引数チェック
  // ****************************************************************
  if((A == NULL) || (n < 1)){
    ERROR__SHOW("#1");
    return -1;
  }
  // ****************************************************************
  // メモリの確保と初期化
  // ****************************************************************
  c = sizeof(INT) * n + sizeof(TYPE) * n * n;
  if((P = (INT*)malloc(c)) == NULL){
    ERROR__SHOW("#2");
    return -1;
  }
  memset(P,0x00,c);
  LU_inv = (TYPE*)&P[n];
  // ****************************************************************
  // LUP分解
  // ****************************************************************
  if(T__MATRIX_LUP_DECOMPOSITION(A,P,n) == -1){
    free(P);
    return -1;
  }
  // ****************************************************************
  // Lの逆行列の計算
  // ****************************************************************
  for(i = 1;i < n;i++){
    for(k = 0;k < i;k++){
      tmp = T__NEGATIVE(A[i * n + k]);
      for(j = 0;j < k;j++){
	LU_inv[i * n + j] = T__FMA(tmp,LU_inv[k * n + j],LU_inv[i * n + j]);
      }
      LU_inv[i * n + k] = T__ADD(LU_inv[i * n + k],tmp);
    }
  }
  // ****************************************************************
  // Uの逆行列の計算
  // ****************************************************************
  LU_inv[(n - 1) * n + (n - 1)] = T__DIV(T__ONE,A[(n - 1) * n + (n - 1)]);
  for(i = n - 2;i >= 0;i--){
    dj = A[i * n + i];
    if(T__EQ(dj,T__ZERO)){
      ERROR__SHOW("#3");
      return -1;
    }
    dj = T__DIV(T__ONE,dj);
    LU_inv[i * n + i] =  dj;
    for(k = i + 1;k < n;k++){
      tmp = T__MUL(T__NEGATIVE(A[i * n + k]),dj);
      for(j = k;j < n;j++){
	LU_inv[i * n + j] = T__FMA(tmp,LU_inv[k * n + j],LU_inv[i * n + j]);
      }
    }
  }
  // ****************************************************************
  // Aの逆行列の計算
  // ****************************************************************
  for(i = 0;i < n;i++){
    for(j = 0;j < i;j++){
      tmp = T__ZERO;
      for(k = i;k < n;k++){
	tmp = T__FMA(LU_inv[i * n + k],LU_inv[k * n + j],tmp);
      }
      A[i * n + P[j]] = tmp;
    }
    for(j = i;j < n;j++){
      tmp = LU_inv[i * n + j];
      for(k = j + 1;k < n;k++){
	tmp = T__FMA(LU_inv[i * n + k],LU_inv[k * n + j],tmp);
      }
      A[i * n + P[j]] = tmp;
    }    
  }
  // ****************************************************************
  // メモリの解放
  // ****************************************************************
  free(P);
  return 0;
}
