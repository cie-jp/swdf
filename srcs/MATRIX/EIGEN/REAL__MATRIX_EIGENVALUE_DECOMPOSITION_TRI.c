/***************************************************************** 
 *
 * 行列の固有値計算関係
 *
 *
 *                           Created  by Mamoru Ota (2018/03/09)
 * 
 *****************************************************************/

#include"MATRIX.h"

// *******************************************************************
// 実対称3重対角行列
//
//            | t0[0]  t1[0]     0      0  ...         0          0  |
//            | t1[0]  t0[1]  t1[1]     0  ...         .          .  |
//            |    0   t1[1]  t0[2]  t1[2] ...         .          .  |
// T        = |    0      0   t1[2]  t0[3] ...         .          .  |
//            |    .      .      .      .              0          0  |
//            |    0      0      0      0  ...  t1[n - 3]         0  | 
//            |    0      0      0      0  ...  t0[n - 2]  t1[n - 2] | 
//            |    0      0      0      0  ...  t1[n - 2]  t0[n - 1] |
//
// の固有値分解T = U diag(l) U^{T}を減次付WilkinsonシフトQR法により計算する.
// ここで, Uは直交行列を表し,
// lはTの固有値からなるベクトルである. 
// また,
//            |  l[0]     0      0      0  ...         0          0  |
//            |    0    l[1]     0      0  ...         .          .  |
//            |    0      0    l[2]     0  ...         .          .  |
// diag(l)  = |    0      0      0      0  ...         .          .  |
//            |    .      .      .      .              0          0  |
//            |    0      0      0      0  ...         0          0  | 
//            |    0      0      0      0  ...   l[n - 2]         0  | 
//            |    0      0      0      0  ...         0    l[n - 1] |
// である. また, |l[0]| > |l[1]| > |l[2]| > ... > |l[n - 1]|である.  
// 
// l[k]に対応する固有ベクトルv[k]は,
//
//            | U[     0  * n + k] |
//            | U[     1  * n + k] |
//            | U[     2  * n + k] |
// v[k]     = | U[     3  * n + k] |
//            |           .        |
//            | U[(n - 2) * n + k] |
//            | U[(n - 1) * n + k] |
//
// であり, 大きさは1で規格化されており, 各固有ベクトルは互いに直交している. 
//
// *******************************************************************
void REAL__MATRIX_EIGENVALUE_DECOMPOSITION_TRI(REAL U [],//(out)[n * n] : 直交行列
                                               REAL t0[],//(io) [n]     : 実対称3重対角行列の対角成分   (固有値配列lが返される)
                                               REAL t1[],//(io) [n - 1] : 実対称3重対角行列の非対角成分 (破壊される)
                                               INT  n){  //(in)         : 行列の次元数
  void *mem;
  REAL *c ;//[n - 1]
  REAL *s ;//[n - 1]
  REAL *r0;//[n]
  REAL *r1;//[n - 1]
  REAL *r2;//[n - 2]
  REAL  emax;
  REAL  emin;
  REAL  shift;
  REAL  tmp1,tmp2;
  INT   i,j,k;
  INT   m;
  REAL  eps = 1.0e-17;
  
  // ******************************************************************
  //  1. 作業変数のメモリ確保
  // ******************************************************************
  if((mem = malloc(sizeof(REAL) * (n - 1)
                 + sizeof(REAL) * (n - 1)
                 + sizeof(REAL) *  n
                 + sizeof(REAL) * (n - 1)
                 + sizeof(REAL) * (n - 2))) == NULL){
    ERROR__SHOW("#1");
    exit(EXIT_FAILURE);
  }

  // ******************************************************************
  //  2. メモリ割り当て
  // ******************************************************************
  c  = (REAL*)mem;
  s  = (REAL*)&c [n - 1];
  r0 = (REAL*)&s [n - 1];
  r1 = (REAL*)&r0[n];
  r2 = (REAL*)&r1[n - 1];
  
  // ******************************************************************
  //  3. Uを単位行列で初期化
  // ******************************************************************  
  for(i = 0;i < n;i++){
    for(j = 0;j < n;j++){
      U[i * n + j] = (i == j) ? REAL__ONE() : REAL__ZERO();
    }
  }

  for(m = n;m > 1;m--){
    while(1){
      // ******************************************************************
      //  4. 右下2x2対称行列の2つの固有値を取得
      // ******************************************************************  
      REAL__MATRIX_EIGENVALUES_2D(&emax,&emin,t0[m - 2],t1[m - 2],t0[m - 1]);
      // ******************************************************************
      //  5. 右下2x2対称行列の非対角成分が十分小さければ減次
      // ******************************************************************  
      if((REAL__MUL(eps,REAL__ABS(emax)) >= REAL__ABS(t1[m - 2])) &&
         (REAL__MUL(eps,REAL__ABS(emin)) >= REAL__ABS(t1[m - 2])) ){
        break;
      }         
      // ******************************************************************
      //  6. QR法のWilkinsonシフト量を固有値から計算
      // ******************************************************************        
      if(REAL__LE(REAL__NORM(REAL__SUB(emax,t0[m - 1])),REAL__NORM(REAL__SUB(emin,t0[m - 1])))){
        shift = emax;
      }else{
        shift = emin;
      }
      // ******************************************************************
      //  7. T      <= T - shift I : Tの対角成分をシフト
      // ******************************************************************              
      for(i = 0;i < m;i++){
        t0[i] = REAL__SUB(t0[i],shift);
      }
      // ******************************************************************
      //  8. (Q, R) <= T           : TのQR分解
      // ******************************************************************                    
      REAL__MATRIX_QR_TRI(c,s,r0,r1,NULL,t0,t1,m);
      // ******************************************************************
      //  9. U      <= QU          : 直交行列の更新
      // ******************************************************************                          
      for(i = 0;i < n;i++){
        for(j = 0;j < m - 1;j++){
          tmp1               = REAL__ADD(REAL__MUL(               c[j] ,U[i * n + j]),REAL__MUL(s[j],U[i * n + (j + 1)]));
          tmp2               = REAL__ADD(REAL__MUL(REAL__NEGATIVE(s[j]),U[i * n + j]),REAL__MUL(c[j],U[i * n + (j + 1)]));
          U[i * n +  j     ] = tmp1;
          U[i * n + (j + 1)] = tmp2;
        }
      }
      // ******************************************************************
      // 10. T      <= RQ          : RQ = Q^{T}TQの計算(Tの相似変換)
      // ******************************************************************                                
      REAL__MATRIX_RQ_TRI(t0,t1,c,s,r0,r1,m);
      // ******************************************************************
      // 11. T      <= T + shift I : シフトを元に戻す
      // ******************************************************************                                      
      for(i = 0;i < m;i++){
        t0[i] = REAL__ADD(t0[i],shift);
      }
    }
  }

  // ******************************************************************
  // 12. 固有値を絶対値に関して降順に並び替え(固有ベクトルも対応するように並び替える)
  // ******************************************************************
  for(i = 0;i < n - 1;i++){
    for(j = i + 1;j < n;j++){
      if(REAL__LT(REAL__ABS(t0[i]),REAL__ABS(t0[j]))){
        tmp1  = t0[i];
        t0[i] = t0[j];
        t0[j] = tmp1;
        for(k = 0;k < n;k++){
          tmp2         = U[k * n + i];
          U[k * n + i] = U[k * n + j];
          U[k * n + j] = tmp2;
        }
      }
    }
  }

  // ******************************************************************
  // 13. 作業変数のメモリ解放
  // ******************************************************************
  free(mem);
}
