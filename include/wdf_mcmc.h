#ifndef _WDF_HMC_H_INCLUDE_#define _WDF_HMC_H_INCLUDE_#include<iostream>#include<complex>#include"./include/cplasma.h"#include"./include/crandom.h"#include"Eigen/Dense"using namespace std;using namespace Eigen;MatrixXcd make_spectral_matrix(MatrixXcd &S){  MatrixXcd St(6,6);  double    Z0 = 120.0 * M_PI;  St(0,0) = S(0,0) / (Z0 * Z0);  St(0,1) = S(0,1) / (Z0 * Z0);  St(0,2) = S(0,2) / (Z0 * Z0);  St(0,3) = S(0,3) /  Z0;  St(0,4) = S(0,4) /  Z0;  St(0,5) = S(0,5) /  Z0;  St(1,0) = S(1,0) / (Z0 * Z0);  St(1,1) = S(1,1) / (Z0 * Z0);  St(1,2) = S(1,2) / (Z0 * Z0);  St(1,3) = S(1,3) /  Z0;  St(1,4) = S(1,4) /  Z0;  St(1,5) = S(1,5) /  Z0;  St(2,0) = S(2,0) / (Z0 * Z0);  St(2,1) = S(2,1) / (Z0 * Z0);  St(2,2) = S(2,2) / (Z0 * Z0);  St(2,3) = S(2,3) /  Z0;  St(2,4) = S(2,4) /  Z0;  St(2,5) = S(2,5) /  Z0;  St(3,0) = S(3,0) /  Z0;  St(3,1) = S(3,1) /  Z0;  St(3,2) = S(3,2) /  Z0;  St(3,3) = S(3,3);  St(3,4) = S(3,4);  St(3,5) = S(3,5);  St(4,0) = S(4,0) /  Z0;  St(4,1) = S(4,1) /  Z0;  St(4,2) = S(4,2) /  Z0;  St(4,3) = S(4,3);  St(4,4) = S(4,4);  St(4,5) = S(4,5);  St(5,0) = S(5,0) /  Z0;  St(5,1) = S(5,1) /  Z0;  St(5,2) = S(5,2) /  Z0;  St(5,3) = S(5,3);  St(5,4) = S(5,4);  St(5,5) = S(5,5);  return St;}namespace WDF{    typedef struct{    unsigned int data_type;    double       theta;    double       phi;      MatrixXcd    IK;    double       dS;    double      *energy_density;    double       energy_density_mode;    double       energy_density_mean;    double       energy_density_l;    double       energy_density_u;  }DATA;    class WDF_MCMC{  private:    DATA  *data;           int    num;            int    num_sample;    double fmin;          double fmax;          double scale;         int    Q;           public:    WDF_MCMC(complex<double> R,             complex<double> L,             complex<double> P,             double         _d,                       int            _num_sample){      int    _Q;      int    Iu,Iv;      double  u, v;      int     N;      int     p = 6;      _Q = (int)ceil(sqrt(2.0) / _d);      N = 0;      for(Iu = -_Q;Iu <= +_Q;Iu++){        for(Iv = -_Q;Iv <= +_Q;Iv++){          u = Iu * _d;          v = Iv * _d;          if(sqrt(u * u + v * v) <= sqrt(2.0)){            N++;            N++;          }        }      }      num = N + 2;      fprintf(stderr,"num = %d\n",num);      data = new DATA[num];      N = 0;      for(Iu = -_Q;Iu <= +_Q;Iu++){        for(Iv = -_Q;Iv <= +_Q;Iv++){          u = Iu * _d;          v = Iv * _d;          if(sqrt(u * u + v * v) <= sqrt(2.0)){            data[N].data_type = 0x00;            data[N].theta     = 2.0 * asin(sqrt(u * u + v * v) / 2.0);            data[N].phi       = atan2(v,u);            data[N].dS        = _d * _d;            if(calc_spectral_matrix_R(data[N].IK,                                      R,L,P,                                      data[N].theta,                                      data[N].phi) == 0){              data[N].data_type = 0x02;            }            data[N].IK  = make_spectral_matrix(data[N].IK);            data[N].IK *= data[N].dS;            N++;            data[N].data_type = 0x00;            data[N].theta     = M_PI - 2.0 * asin(sqrt(u * u + v * v) / 2.0);            data[N].phi       = atan2(v,u);            data[N].dS        = _d * _d;            if(calc_spectral_matrix_R(data[N].IK,                                      R,L,P,                                      data[N].theta,                                      data[N].phi) == 0){              data[N].data_type = 0x02;            }            data[N].IK  = make_spectral_matrix(data[N].IK);            data[N].IK *= data[N].dS;            N++;          }        }      }      data[N].data_type = 0x01;      data[N].theta     = 0.0;      data[N].phi       = 0.0;      data[N].dS        = 0.0;      data[N].IK        = MatrixXcd::Zero(p,p);      data[N].IK(0,0)   = 1.0;      data[N].IK(1,1)   = 1.0;      data[N].IK(2,2)   = 1.0;      N++;      data[N].data_type = 0x01;      data[N].theta     = 0.0;      data[N].phi       = 0.0;      data[N].dS        = 0.0;      data[N].IK        = MatrixXcd::Zero(p,p);      data[N].IK(3,3)   = 1.0;      data[N].IK(4,4)   = 1.0;      data[N].IK(5,5)   = 1.0;      N++;      Q          =          64 * 8.0 * 4.0 * 2.0;      fmax       =        32.0;      num_sample = _num_sample;      for(int n = 0;n < num;n++){	data[n].energy_density = new double[_num_sample];	for(int i = 0;i < _num_sample;i++){	  data[n].energy_density[i] = 1.0 / Q * fmax;	}	data[n].energy_density_mode = 1.0 / Q * fmax;	data[n].energy_density_mean = 1.0 / Q * fmax;	data[n].energy_density_l    = 1.0 / Q * fmax;	data[n].energy_density_u    = 1.0 / Q * fmax;      }      // ================================================    }    ~WDF_MCMC(){      for(int n = 0;n < num;n++){	delete[] data[n].energy_density;      }      delete[] data;    }    void estimation(MatrixXcd _W,int ave_num,int burn_in){      DATA     *data_ptr[num];      int       L;      L = 0;      for(int n = 0;n < num;n++){        if(data[n].data_type == 0x01){	  continue;        }        if(data[n].data_type == 0x02){	  continue;        }        data_ptr[L] = &data[n];        L++;      }            int       p  = _W.rows();      int       N  = ave_num;      VectorXd  f  = VectorXd::Zero(L);      MatrixXcd W  = _W / (_W(3,3) + _W(4,4) + _W(5,5));      CRandom   cr;      MatrixXcd S,S_inv;      double    ln_prob[Q];      double    prob[Q];      double    max_ln_prob;      double    sum;      double    A,B;      double    beta = 1.0;            for(int l = 0;l < L;l++){        f(l) = 1.0 / (double)Q * fmax;      }      S = MatrixXcd::Zero(p,p);          for(int l = 0;l < L;l++){        S += data_ptr[l]->IK * f(l);      }      for(int sample_id = -burn_in;sample_id < num_sample;sample_id++){        if(sample_id <= 0){          beta = (burn_in + sample_id) / (double)burn_in;          fprintf(stderr,"beta = %e\n",beta);        }        for(int l = 0;l < L;l++){          S -= data_ptr[l]->IK * f(l);          S_inv = S.inverse();          A     = real((            S_inv * data_ptr[l]->IK).trace());          B     = real((S_inv * W * S_inv * data_ptr[l]->IK).trace());          for(int q = 0;q < Q;q++){            f(l) = (q + 1) / (double)Q * fmax;            ln_prob[q]  = beta * (N * B * f(l) / (1.0 + A * f(l)) - N * log(1.0 + A * f(l)));          }          max_ln_prob = ln_prob[0];          for(int q = 1;q < Q;q++){            if(max_ln_prob < ln_prob[q]){               max_ln_prob = ln_prob[q];            }          }          for(int q = 0;q < Q;q++){            prob[q] = exp(ln_prob[q] - max_ln_prob);          }          sum = 0.0;          for(int q = 0;q < Q;q++){            sum += prob[q];          }          for(int q = 0;q < Q;q++){            prob[q] /= sum;          }               f(l) = (cr.multinomial(prob,Q) + 1) / (double)Q * fmax;          S += data_ptr[l]->IK * f(l);        }                if(sample_id >= 0){          for(int l = 0;l < L;l++){            data_ptr[l]->energy_density[sample_id] = f(l);          }        }        fprintf(stderr,"sample_id = %5d\n",sample_id);      }            FILE *fp;      for(int n = 0;n < num;n++){	data[n].energy_density_mean = 0.0;	for(int sample_id = 0;sample_id < num_sample;sample_id++){	  data[n].energy_density_mean += data[n].energy_density[sample_id];	}	data[n].energy_density_mean /= (double)num_sample;      }      fp = fopen("mean.csv","w");      for(int n = 0;n < num;n++){        if(data[n].data_type == 0x01){          continue;        }	fprintf(fp,"%e,%e,%e\n",		180.0 / M_PI * data[n].phi,		90.0 - 180.0 / M_PI * data[n].theta,		data[n].energy_density_mean);      }      fclose(fp);      double *ptr;      double  tmp;      int     idx_min;      int     idx_max;            idx_min = (int)(num_sample * 0.025);      idx_max = (int)(num_sample * 0.975);      for(int n = 0;n < num;n++){	fprintf(stderr,"sphere id : %d\n",n);	ptr = data[n].energy_density;	for(int i = 0;i < num_sample - 1;i++){	  for(int j = i + 1;j < num_sample;j++){	    if(ptr[i] > ptr[j]){	      tmp    = ptr[i];	      ptr[i] = ptr[j];	      ptr[j] = tmp;	    }	  }      	}	data[n].energy_density_l = ptr[idx_min];	data[n].energy_density_u = ptr[idx_max];      }      fp = fopen("lower.csv","w");      for(int n = 0;n < num;n++){        if(data[n].data_type == 0x01){          continue;        }	fprintf(fp,"%e,%e,%e\n",		180.0 / M_PI * data[n].phi,          		90.0 - 180.0 / M_PI * data[n].theta, 		data[n].energy_density_l);                 }      fclose(fp);      fp = fopen("upper.csv","w");      for(int n = 0;n < num;n++){        if(data[n].data_type == 0x01){          continue;        }	fprintf(fp,"%e,%e,%e\n",		180.0 / M_PI * data[n].phi,         		90.0 - 180.0 / M_PI * data[n].theta,		data[n].energy_density_u);                }      fclose(fp);    }  };  }#endif